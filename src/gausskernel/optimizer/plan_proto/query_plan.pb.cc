// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: query_plan.proto

#include "query_plan.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace proto_plan {
constexpr RightRefState::RightRefState(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : explicitattrnos_()
  , _explicitattrnos_cached_byte_size_(0)
  , constvalues_()
  , values_()
  , _values_cached_byte_size_(0)
  , hasexecs_()
  , isnulls_()
  , usexplicitattrnos_()
  , _usexplicitattrnos_cached_byte_size_(0)
  , explicitattrlen_(0)
  , colcnt_(0)
  , issupported_(false)
  , isinserthasrightref_(false)
  , isupsert_(false)
  , isupserthasrightref_(false)
  , usexplicitattrlen_(0){}
struct RightRefStateDefaultTypeInternal {
  constexpr RightRefStateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RightRefStateDefaultTypeInternal() {}
  union {
    RightRefState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RightRefStateDefaultTypeInternal _RightRefState_default_instance_;
constexpr Plan::Plan(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : operatormemkb_()
  , _operatormemkb_cached_byte_size_(0)
  , ng_operatormemkbarray_()
  , _ng_operatormemkbarray_cached_byte_size_(0)
  , targetlist_(nullptr)
  , qual_(nullptr)
  , lefttree_(nullptr)
  , righttree_(nullptr)
  , initplan_(nullptr)
  , distributed_keys_(nullptr)
  , exec_nodes_(nullptr)
  , extparam_(nullptr)
  , allparam_(nullptr)
  , var_list_(nullptr)
  , filterindexlist_(nullptr)
  , flatlist_(nullptr)
  , rightrefstate_(nullptr)
  , plan_node_id_(0u)
  , parent_node_id_(0u)
  , startup_cost_(0)
  , total_cost_(0)
  , exec_type_(0)

  , plan_width_(0)
  , plan_rows_(0)
  , multiple_(0)
  , pred_rows_(0)
  , pred_startup_time_(0)
  , dop_(0)
  , recursive_union_plan_nodeid_(0)
  , pred_total_time_(0)
  , pred_max_memory_(int64_t{0})
  , control_plan_nodeid_(0)
  , recursive_union_controller_(false)
  , is_sync_plannode_(false)
  , ispwj_(false)
  , vec_output_(false)
  , paramno_(0)
  , subparamno_(0)
  , hasuniqueresults_(false)
  , isdeltatable_(false)
  , parallel_enabled_(false)
  , hashashfilter_(false)
  , operatormaxmem_(0)
  , innerdistinct_(0)
  , outerdistinct_(0)
  , ng_num_(0){}
struct PlanDefaultTypeInternal {
  constexpr PlanDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PlanDefaultTypeInternal() {}
  union {
    Plan _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PlanDefaultTypeInternal _Plan_default_instance_;
}  // namespace proto_plan
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_query_5fplan_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_query_5fplan_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_query_5fplan_2eproto = nullptr;

const uint32_t TableStruct_query_5fplan_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto_plan::RightRefState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto_plan::RightRefState, issupported_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::RightRefState, isinserthasrightref_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::RightRefState, explicitattrlen_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::RightRefState, explicitattrnos_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::RightRefState, constvalues_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::RightRefState, colcnt_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::RightRefState, values_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::RightRefState, hasexecs_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::RightRefState, isnulls_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::RightRefState, isupsert_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::RightRefState, isupserthasrightref_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::RightRefState, usexplicitattrlen_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::RightRefState, usexplicitattrnos_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, plan_node_id_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, parent_node_id_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, exec_type_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, startup_cost_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, total_cost_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, plan_rows_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, multiple_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, plan_width_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, dop_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, pred_rows_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, pred_startup_time_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, pred_total_time_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, pred_max_memory_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, recursive_union_plan_nodeid_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, recursive_union_controller_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, control_plan_nodeid_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, is_sync_plannode_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, targetlist_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, qual_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, lefttree_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, righttree_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, ispwj_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, paramno_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, subparamno_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, initplan_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, distributed_keys_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, exec_nodes_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, extparam_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, allparam_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, vec_output_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, hasuniqueresults_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, isdeltatable_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, operatormemkb_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, operatormaxmem_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, parallel_enabled_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, hashashfilter_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, var_list_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, filterindexlist_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, ng_operatormemkbarray_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, ng_num_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, innerdistinct_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, outerdistinct_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, flatlist_),
  PROTOBUF_FIELD_OFFSET(::proto_plan::Plan, rightrefstate_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::proto_plan::RightRefState)},
  { 19, -1, -1, sizeof(::proto_plan::Plan)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::proto_plan::_RightRefState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::proto_plan::_Plan_default_instance_),
};

const char descriptor_table_protodef_query_5fplan_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\020query_plan.proto\022\nproto_plan\032\017execNode"
  "s.proto\032\renumtag.proto\"\303\002\n\rRightRefState"
  "\022\023\n\013isSupported\030\001 \001(\010\022\033\n\023isInsertHasRigh"
  "tRef\030\002 \001(\010\022\027\n\017explicitAttrLen\030\003 \001(\005\022\027\n\017e"
  "xplicitAttrNos\030\004 \003(\005\022&\n\013constValues\030\005 \003("
  "\0132\021.proto_plan.Const\022\016\n\006colCnt\030\006 \001(\005\022\016\n\006"
  "values\030\007 \003(\004\022\020\n\010hasExecs\030\010 \003(\010\022\017\n\007isNull"
  "s\030\t \003(\010\022\020\n\010isUpsert\030\n \001(\010\022\033\n\023isUpsertHas"
  "RightRef\030\013 \001(\010\022\031\n\021usExplicitAttrLen\030\014 \001("
  "\005\022\031\n\021usExplicitAttrNos\030\r \003(\005\"\356\t\n\004Plan\022\024\n"
  "\014plan_node_id\030\001 \001(\r\022\026\n\016parent_node_id\030\002 "
  "\001(\r\0222\n\texec_type\030\003 \001(\0162\037.proto_plan.Remo"
  "teQueryExecType\022\024\n\014startup_cost\030\004 \001(\001\022\022\n"
  "\ntotal_cost\030\005 \001(\001\022\021\n\tplan_rows\030\006 \001(\001\022\020\n\010"
  "multiple\030\007 \001(\001\022\022\n\nplan_width\030\010 \001(\005\022\013\n\003do"
  "p\030\t \001(\005\022\021\n\tpred_rows\030\n \001(\001\022\031\n\021pred_start"
  "up_time\030\013 \001(\001\022\027\n\017pred_total_time\030\014 \001(\001\022\027"
  "\n\017pred_max_memory\030\r \001(\003\022#\n\033recursive_uni"
  "on_plan_nodeid\030\016 \001(\005\022\"\n\032recursive_union_"
  "controller\030\017 \001(\010\022\033\n\023control_plan_nodeid\030"
  "\020 \001(\005\022\030\n\020is_sync_plannode\030\021 \001(\010\022$\n\ntarge"
  "tlist\030\022 \001(\0132\020.proto_plan.List\022\036\n\004qual\030\023 "
  "\001(\0132\020.proto_plan.List\022\"\n\010lefttree\030\024 \001(\0132"
  "\020.proto_plan.Plan\022#\n\trighttree\030\025 \001(\0132\020.p"
  "roto_plan.Plan\022\r\n\005ispwj\030\026 \001(\010\022\017\n\007paramno"
  "\030\027 \001(\005\022\022\n\nsubparamno\030\030 \001(\005\022\"\n\010initPlan\030\031"
  " \001(\0132\020.proto_plan.List\022*\n\020distributed_ke"
  "ys\030\032 \001(\0132\020.proto_plan.List\022)\n\nexec_nodes"
  "\030\033 \001(\0132\025.proto_plan.ExecNodes\022\'\n\010extPara"
  "m\030\034 \001(\0132\025.proto_plan.Bitmapset\022\'\n\010allPar"
  "am\030\035 \001(\0132\025.proto_plan.Bitmapset\022\022\n\nvec_o"
  "utput\030\036 \001(\010\022\030\n\020hasUniqueResults\030\037 \001(\010\022\024\n"
  "\014isDeltaTable\030  \001(\010\022\025\n\roperatorMemKB\030! \003"
  "(\005\022\026\n\016operatorMaxMem\030\" \001(\005\022\030\n\020parallel_e"
  "nabled\030# \001(\010\022\025\n\rhasHashFilter\030$ \001(\010\022\"\n\010v"
  "ar_list\030% \001(\0132\020.proto_plan.List\022)\n\017filte"
  "rIndexList\030& \001(\0132\020.proto_plan.List\022\035\n\025ng"
  "_operatorMemKBArray\030\' \003(\005\022\016\n\006ng_num\030( \001("
  "\005\022\025\n\rinnerdistinct\030) \001(\001\022\025\n\routerdistinc"
  "t\030* \001(\001\022\"\n\010flatList\030+ \001(\0132\020.proto_plan.L"
  "ist\0220\n\rrightRefState\030, \001(\0132\031.proto_plan."
  "RightRefStateb\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_query_5fplan_2eproto_deps[2] = {
  &::descriptor_table_enumtag_2eproto,
  &::descriptor_table_execNodes_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_query_5fplan_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_query_5fplan_2eproto = {
  false, false, 1661, descriptor_table_protodef_query_5fplan_2eproto, "query_plan.proto", 
  &descriptor_table_query_5fplan_2eproto_once, descriptor_table_query_5fplan_2eproto_deps, 2, 2,
  schemas, file_default_instances, TableStruct_query_5fplan_2eproto::offsets,
  file_level_metadata_query_5fplan_2eproto, file_level_enum_descriptors_query_5fplan_2eproto, file_level_service_descriptors_query_5fplan_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_query_5fplan_2eproto_getter() {
  return &descriptor_table_query_5fplan_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_query_5fplan_2eproto(&descriptor_table_query_5fplan_2eproto);
namespace proto_plan {

// ===================================================================

class RightRefState::_Internal {
 public:
};

void RightRefState::clear_constvalues() {
  constvalues_.Clear();
}
RightRefState::RightRefState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  explicitattrnos_(arena),
  constvalues_(arena),
  values_(arena),
  hasexecs_(arena),
  isnulls_(arena),
  usexplicitattrnos_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto_plan.RightRefState)
}
RightRefState::RightRefState(const RightRefState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      explicitattrnos_(from.explicitattrnos_),
      constvalues_(from.constvalues_),
      values_(from.values_),
      hasexecs_(from.hasexecs_),
      isnulls_(from.isnulls_),
      usexplicitattrnos_(from.usexplicitattrnos_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&explicitattrlen_, &from.explicitattrlen_,
    static_cast<size_t>(reinterpret_cast<char*>(&usexplicitattrlen_) -
    reinterpret_cast<char*>(&explicitattrlen_)) + sizeof(usexplicitattrlen_));
  // @@protoc_insertion_point(copy_constructor:proto_plan.RightRefState)
}

inline void RightRefState::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&explicitattrlen_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&usexplicitattrlen_) -
    reinterpret_cast<char*>(&explicitattrlen_)) + sizeof(usexplicitattrlen_));
}

RightRefState::~RightRefState() {
  // @@protoc_insertion_point(destructor:proto_plan.RightRefState)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RightRefState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RightRefState::ArenaDtor(void* object) {
  RightRefState* _this = reinterpret_cast< RightRefState* >(object);
  (void)_this;
}
void RightRefState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RightRefState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RightRefState::Clear() {
// @@protoc_insertion_point(message_clear_start:proto_plan.RightRefState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  explicitattrnos_.Clear();
  constvalues_.Clear();
  values_.Clear();
  hasexecs_.Clear();
  isnulls_.Clear();
  usexplicitattrnos_.Clear();
  ::memset(&explicitattrlen_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&usexplicitattrlen_) -
      reinterpret_cast<char*>(&explicitattrlen_)) + sizeof(usexplicitattrlen_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RightRefState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool isSupported = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          issupported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isInsertHasRightRef = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          isinserthasrightref_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 explicitAttrLen = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          explicitattrlen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 explicitAttrNos = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_explicitattrnos(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_explicitattrnos(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .proto_plan.Const constValues = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_constvalues(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int32 colCnt = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          colcnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 values = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_values(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 56) {
          _internal_add_values(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bool hasExecs = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_hasexecs(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 64) {
          _internal_add_hasexecs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bool isNulls = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_isnulls(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 72) {
          _internal_add_isnulls(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isUpsert = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          isupsert_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isUpsertHasRightRef = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          isupserthasrightref_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 usExplicitAttrLen = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          usexplicitattrlen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 usExplicitAttrNos = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_usexplicitattrnos(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 104) {
          _internal_add_usexplicitattrnos(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RightRefState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto_plan.RightRefState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool isSupported = 1;
  if (this->_internal_issupported() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_issupported(), target);
  }

  // bool isInsertHasRightRef = 2;
  if (this->_internal_isinserthasrightref() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_isinserthasrightref(), target);
  }

  // int32 explicitAttrLen = 3;
  if (this->_internal_explicitattrlen() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_explicitattrlen(), target);
  }

  // repeated int32 explicitAttrNos = 4;
  {
    int byte_size = _explicitattrnos_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          4, _internal_explicitattrnos(), byte_size, target);
    }
  }

  // repeated .proto_plan.Const constValues = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_constvalues_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_constvalues(i), target, stream);
  }

  // int32 colCnt = 6;
  if (this->_internal_colcnt() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_colcnt(), target);
  }

  // repeated uint64 values = 7;
  {
    int byte_size = _values_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          7, _internal_values(), byte_size, target);
    }
  }

  // repeated bool hasExecs = 8;
  if (this->_internal_hasexecs_size() > 0) {
    target = stream->WriteFixedPacked(8, _internal_hasexecs(), target);
  }

  // repeated bool isNulls = 9;
  if (this->_internal_isnulls_size() > 0) {
    target = stream->WriteFixedPacked(9, _internal_isnulls(), target);
  }

  // bool isUpsert = 10;
  if (this->_internal_isupsert() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_isupsert(), target);
  }

  // bool isUpsertHasRightRef = 11;
  if (this->_internal_isupserthasrightref() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_isupserthasrightref(), target);
  }

  // int32 usExplicitAttrLen = 12;
  if (this->_internal_usexplicitattrlen() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(12, this->_internal_usexplicitattrlen(), target);
  }

  // repeated int32 usExplicitAttrNos = 13;
  {
    int byte_size = _usexplicitattrnos_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          13, _internal_usexplicitattrnos(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto_plan.RightRefState)
  return target;
}

size_t RightRefState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto_plan.RightRefState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 explicitAttrNos = 4;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->explicitattrnos_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _explicitattrnos_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .proto_plan.Const constValues = 5;
  total_size += 1UL * this->_internal_constvalues_size();
  for (const auto& msg : this->constvalues_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint64 values = 7;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->values_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _values_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated bool hasExecs = 8;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_hasexecs_size());
    size_t data_size = 1UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated bool isNulls = 9;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_isnulls_size());
    size_t data_size = 1UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated int32 usExplicitAttrNos = 13;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->usexplicitattrnos_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _usexplicitattrnos_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int32 explicitAttrLen = 3;
  if (this->_internal_explicitattrlen() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_explicitattrlen());
  }

  // int32 colCnt = 6;
  if (this->_internal_colcnt() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_colcnt());
  }

  // bool isSupported = 1;
  if (this->_internal_issupported() != 0) {
    total_size += 1 + 1;
  }

  // bool isInsertHasRightRef = 2;
  if (this->_internal_isinserthasrightref() != 0) {
    total_size += 1 + 1;
  }

  // bool isUpsert = 10;
  if (this->_internal_isupsert() != 0) {
    total_size += 1 + 1;
  }

  // bool isUpsertHasRightRef = 11;
  if (this->_internal_isupserthasrightref() != 0) {
    total_size += 1 + 1;
  }

  // int32 usExplicitAttrLen = 12;
  if (this->_internal_usexplicitattrlen() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_usexplicitattrlen());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RightRefState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RightRefState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RightRefState::GetClassData() const { return &_class_data_; }

void RightRefState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RightRefState *>(to)->MergeFrom(
      static_cast<const RightRefState &>(from));
}


void RightRefState::MergeFrom(const RightRefState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto_plan.RightRefState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  explicitattrnos_.MergeFrom(from.explicitattrnos_);
  constvalues_.MergeFrom(from.constvalues_);
  values_.MergeFrom(from.values_);
  hasexecs_.MergeFrom(from.hasexecs_);
  isnulls_.MergeFrom(from.isnulls_);
  usexplicitattrnos_.MergeFrom(from.usexplicitattrnos_);
  if (from._internal_explicitattrlen() != 0) {
    _internal_set_explicitattrlen(from._internal_explicitattrlen());
  }
  if (from._internal_colcnt() != 0) {
    _internal_set_colcnt(from._internal_colcnt());
  }
  if (from._internal_issupported() != 0) {
    _internal_set_issupported(from._internal_issupported());
  }
  if (from._internal_isinserthasrightref() != 0) {
    _internal_set_isinserthasrightref(from._internal_isinserthasrightref());
  }
  if (from._internal_isupsert() != 0) {
    _internal_set_isupsert(from._internal_isupsert());
  }
  if (from._internal_isupserthasrightref() != 0) {
    _internal_set_isupserthasrightref(from._internal_isupserthasrightref());
  }
  if (from._internal_usexplicitattrlen() != 0) {
    _internal_set_usexplicitattrlen(from._internal_usexplicitattrlen());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RightRefState::CopyFrom(const RightRefState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto_plan.RightRefState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RightRefState::IsInitialized() const {
  return true;
}

void RightRefState::InternalSwap(RightRefState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  explicitattrnos_.InternalSwap(&other->explicitattrnos_);
  constvalues_.InternalSwap(&other->constvalues_);
  values_.InternalSwap(&other->values_);
  hasexecs_.InternalSwap(&other->hasexecs_);
  isnulls_.InternalSwap(&other->isnulls_);
  usexplicitattrnos_.InternalSwap(&other->usexplicitattrnos_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RightRefState, usexplicitattrlen_)
      + sizeof(RightRefState::usexplicitattrlen_)
      - PROTOBUF_FIELD_OFFSET(RightRefState, explicitattrlen_)>(
          reinterpret_cast<char*>(&explicitattrlen_),
          reinterpret_cast<char*>(&other->explicitattrlen_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RightRefState::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_query_5fplan_2eproto_getter, &descriptor_table_query_5fplan_2eproto_once,
      file_level_metadata_query_5fplan_2eproto[0]);
}

// ===================================================================

class Plan::_Internal {
 public:
  static const ::proto_plan::List& targetlist(const Plan* msg);
  static const ::proto_plan::List& qual(const Plan* msg);
  static const ::proto_plan::Plan& lefttree(const Plan* msg);
  static const ::proto_plan::Plan& righttree(const Plan* msg);
  static const ::proto_plan::List& initplan(const Plan* msg);
  static const ::proto_plan::List& distributed_keys(const Plan* msg);
  static const ::proto_plan::ExecNodes& exec_nodes(const Plan* msg);
  static const ::proto_plan::Bitmapset& extparam(const Plan* msg);
  static const ::proto_plan::Bitmapset& allparam(const Plan* msg);
  static const ::proto_plan::List& var_list(const Plan* msg);
  static const ::proto_plan::List& filterindexlist(const Plan* msg);
  static const ::proto_plan::List& flatlist(const Plan* msg);
  static const ::proto_plan::RightRefState& rightrefstate(const Plan* msg);
};

const ::proto_plan::List&
Plan::_Internal::targetlist(const Plan* msg) {
  return *msg->targetlist_;
}
const ::proto_plan::List&
Plan::_Internal::qual(const Plan* msg) {
  return *msg->qual_;
}
const ::proto_plan::Plan&
Plan::_Internal::lefttree(const Plan* msg) {
  return *msg->lefttree_;
}
const ::proto_plan::Plan&
Plan::_Internal::righttree(const Plan* msg) {
  return *msg->righttree_;
}
const ::proto_plan::List&
Plan::_Internal::initplan(const Plan* msg) {
  return *msg->initplan_;
}
const ::proto_plan::List&
Plan::_Internal::distributed_keys(const Plan* msg) {
  return *msg->distributed_keys_;
}
const ::proto_plan::ExecNodes&
Plan::_Internal::exec_nodes(const Plan* msg) {
  return *msg->exec_nodes_;
}
const ::proto_plan::Bitmapset&
Plan::_Internal::extparam(const Plan* msg) {
  return *msg->extparam_;
}
const ::proto_plan::Bitmapset&
Plan::_Internal::allparam(const Plan* msg) {
  return *msg->allparam_;
}
const ::proto_plan::List&
Plan::_Internal::var_list(const Plan* msg) {
  return *msg->var_list_;
}
const ::proto_plan::List&
Plan::_Internal::filterindexlist(const Plan* msg) {
  return *msg->filterindexlist_;
}
const ::proto_plan::List&
Plan::_Internal::flatlist(const Plan* msg) {
  return *msg->flatlist_;
}
const ::proto_plan::RightRefState&
Plan::_Internal::rightrefstate(const Plan* msg) {
  return *msg->rightrefstate_;
}
void Plan::clear_targetlist() {
  if (GetArenaForAllocation() == nullptr && targetlist_ != nullptr) {
    delete targetlist_;
  }
  targetlist_ = nullptr;
}
void Plan::clear_qual() {
  if (GetArenaForAllocation() == nullptr && qual_ != nullptr) {
    delete qual_;
  }
  qual_ = nullptr;
}
void Plan::clear_initplan() {
  if (GetArenaForAllocation() == nullptr && initplan_ != nullptr) {
    delete initplan_;
  }
  initplan_ = nullptr;
}
void Plan::clear_distributed_keys() {
  if (GetArenaForAllocation() == nullptr && distributed_keys_ != nullptr) {
    delete distributed_keys_;
  }
  distributed_keys_ = nullptr;
}
void Plan::clear_exec_nodes() {
  if (GetArenaForAllocation() == nullptr && exec_nodes_ != nullptr) {
    delete exec_nodes_;
  }
  exec_nodes_ = nullptr;
}
void Plan::clear_extparam() {
  if (GetArenaForAllocation() == nullptr && extparam_ != nullptr) {
    delete extparam_;
  }
  extparam_ = nullptr;
}
void Plan::clear_allparam() {
  if (GetArenaForAllocation() == nullptr && allparam_ != nullptr) {
    delete allparam_;
  }
  allparam_ = nullptr;
}
void Plan::clear_var_list() {
  if (GetArenaForAllocation() == nullptr && var_list_ != nullptr) {
    delete var_list_;
  }
  var_list_ = nullptr;
}
void Plan::clear_filterindexlist() {
  if (GetArenaForAllocation() == nullptr && filterindexlist_ != nullptr) {
    delete filterindexlist_;
  }
  filterindexlist_ = nullptr;
}
void Plan::clear_flatlist() {
  if (GetArenaForAllocation() == nullptr && flatlist_ != nullptr) {
    delete flatlist_;
  }
  flatlist_ = nullptr;
}
Plan::Plan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  operatormemkb_(arena),
  ng_operatormemkbarray_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:proto_plan.Plan)
}
Plan::Plan(const Plan& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      operatormemkb_(from.operatormemkb_),
      ng_operatormemkbarray_(from.ng_operatormemkbarray_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_targetlist()) {
    targetlist_ = new ::proto_plan::List(*from.targetlist_);
  } else {
    targetlist_ = nullptr;
  }
  if (from._internal_has_qual()) {
    qual_ = new ::proto_plan::List(*from.qual_);
  } else {
    qual_ = nullptr;
  }
  if (from._internal_has_lefttree()) {
    lefttree_ = new ::proto_plan::Plan(*from.lefttree_);
  } else {
    lefttree_ = nullptr;
  }
  if (from._internal_has_righttree()) {
    righttree_ = new ::proto_plan::Plan(*from.righttree_);
  } else {
    righttree_ = nullptr;
  }
  if (from._internal_has_initplan()) {
    initplan_ = new ::proto_plan::List(*from.initplan_);
  } else {
    initplan_ = nullptr;
  }
  if (from._internal_has_distributed_keys()) {
    distributed_keys_ = new ::proto_plan::List(*from.distributed_keys_);
  } else {
    distributed_keys_ = nullptr;
  }
  if (from._internal_has_exec_nodes()) {
    exec_nodes_ = new ::proto_plan::ExecNodes(*from.exec_nodes_);
  } else {
    exec_nodes_ = nullptr;
  }
  if (from._internal_has_extparam()) {
    extparam_ = new ::proto_plan::Bitmapset(*from.extparam_);
  } else {
    extparam_ = nullptr;
  }
  if (from._internal_has_allparam()) {
    allparam_ = new ::proto_plan::Bitmapset(*from.allparam_);
  } else {
    allparam_ = nullptr;
  }
  if (from._internal_has_var_list()) {
    var_list_ = new ::proto_plan::List(*from.var_list_);
  } else {
    var_list_ = nullptr;
  }
  if (from._internal_has_filterindexlist()) {
    filterindexlist_ = new ::proto_plan::List(*from.filterindexlist_);
  } else {
    filterindexlist_ = nullptr;
  }
  if (from._internal_has_flatlist()) {
    flatlist_ = new ::proto_plan::List(*from.flatlist_);
  } else {
    flatlist_ = nullptr;
  }
  if (from._internal_has_rightrefstate()) {
    rightrefstate_ = new ::proto_plan::RightRefState(*from.rightrefstate_);
  } else {
    rightrefstate_ = nullptr;
  }
  ::memcpy(&plan_node_id_, &from.plan_node_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&ng_num_) -
    reinterpret_cast<char*>(&plan_node_id_)) + sizeof(ng_num_));
  // @@protoc_insertion_point(copy_constructor:proto_plan.Plan)
}

inline void Plan::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&targetlist_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ng_num_) -
    reinterpret_cast<char*>(&targetlist_)) + sizeof(ng_num_));
}

Plan::~Plan() {
  // @@protoc_insertion_point(destructor:proto_plan.Plan)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Plan::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete targetlist_;
  if (this != internal_default_instance()) delete qual_;
  if (this != internal_default_instance()) delete lefttree_;
  if (this != internal_default_instance()) delete righttree_;
  if (this != internal_default_instance()) delete initplan_;
  if (this != internal_default_instance()) delete distributed_keys_;
  if (this != internal_default_instance()) delete exec_nodes_;
  if (this != internal_default_instance()) delete extparam_;
  if (this != internal_default_instance()) delete allparam_;
  if (this != internal_default_instance()) delete var_list_;
  if (this != internal_default_instance()) delete filterindexlist_;
  if (this != internal_default_instance()) delete flatlist_;
  if (this != internal_default_instance()) delete rightrefstate_;
}

void Plan::ArenaDtor(void* object) {
  Plan* _this = reinterpret_cast< Plan* >(object);
  (void)_this;
}
void Plan::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Plan::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Plan::Clear() {
// @@protoc_insertion_point(message_clear_start:proto_plan.Plan)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  operatormemkb_.Clear();
  ng_operatormemkbarray_.Clear();
  if (GetArenaForAllocation() == nullptr && targetlist_ != nullptr) {
    delete targetlist_;
  }
  targetlist_ = nullptr;
  if (GetArenaForAllocation() == nullptr && qual_ != nullptr) {
    delete qual_;
  }
  qual_ = nullptr;
  if (GetArenaForAllocation() == nullptr && lefttree_ != nullptr) {
    delete lefttree_;
  }
  lefttree_ = nullptr;
  if (GetArenaForAllocation() == nullptr && righttree_ != nullptr) {
    delete righttree_;
  }
  righttree_ = nullptr;
  if (GetArenaForAllocation() == nullptr && initplan_ != nullptr) {
    delete initplan_;
  }
  initplan_ = nullptr;
  if (GetArenaForAllocation() == nullptr && distributed_keys_ != nullptr) {
    delete distributed_keys_;
  }
  distributed_keys_ = nullptr;
  if (GetArenaForAllocation() == nullptr && exec_nodes_ != nullptr) {
    delete exec_nodes_;
  }
  exec_nodes_ = nullptr;
  if (GetArenaForAllocation() == nullptr && extparam_ != nullptr) {
    delete extparam_;
  }
  extparam_ = nullptr;
  if (GetArenaForAllocation() == nullptr && allparam_ != nullptr) {
    delete allparam_;
  }
  allparam_ = nullptr;
  if (GetArenaForAllocation() == nullptr && var_list_ != nullptr) {
    delete var_list_;
  }
  var_list_ = nullptr;
  if (GetArenaForAllocation() == nullptr && filterindexlist_ != nullptr) {
    delete filterindexlist_;
  }
  filterindexlist_ = nullptr;
  if (GetArenaForAllocation() == nullptr && flatlist_ != nullptr) {
    delete flatlist_;
  }
  flatlist_ = nullptr;
  if (GetArenaForAllocation() == nullptr && rightrefstate_ != nullptr) {
    delete rightrefstate_;
  }
  rightrefstate_ = nullptr;
  ::memset(&plan_node_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ng_num_) -
      reinterpret_cast<char*>(&plan_node_id_)) + sizeof(ng_num_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Plan::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 plan_node_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          plan_node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 parent_node_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          parent_node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto_plan.RemoteQueryExecType exec_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_exec_type(static_cast<::proto_plan::RemoteQueryExecType>(val));
        } else
          goto handle_unusual;
        continue;
      // double startup_cost = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          startup_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double total_cost = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          total_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double plan_rows = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          plan_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double multiple = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          multiple_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 plan_width = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          plan_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dop = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          dop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double pred_rows = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          pred_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double pred_startup_time = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          pred_startup_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double pred_total_time = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          pred_total_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int64 pred_max_memory = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          pred_max_memory_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 recursive_union_plan_nodeid = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          recursive_union_plan_nodeid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool recursive_union_controller = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          recursive_union_controller_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 control_plan_nodeid = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          control_plan_nodeid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_sync_plannode = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          is_sync_plannode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto_plan.List targetlist = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_targetlist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto_plan.List qual = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_qual(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto_plan.Plan lefttree = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_lefttree(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto_plan.Plan righttree = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_righttree(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool ispwj = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          ispwj_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 paramno = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          paramno_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 subparamno = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          subparamno_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto_plan.List initPlan = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_initplan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto_plan.List distributed_keys = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_distributed_keys(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto_plan.ExecNodes exec_nodes = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_exec_nodes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto_plan.Bitmapset extParam = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_extparam(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto_plan.Bitmapset allParam = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_allparam(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool vec_output = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          vec_output_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool hasUniqueResults = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          hasuniqueresults_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isDeltaTable = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          isdeltatable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 operatorMemKB = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_operatormemkb(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_operatormemkb(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 operatorMaxMem = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          operatormaxmem_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool parallel_enabled = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          parallel_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool hasHashFilter = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          hashashfilter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto_plan.List var_list = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_var_list(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto_plan.List filterIndexList = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_filterindexlist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 ng_operatorMemKBArray = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_ng_operatormemkbarray(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 56) {
          _internal_add_ng_operatormemkbarray(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 ng_num = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          ng_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double innerdistinct = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          innerdistinct_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double outerdistinct = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          outerdistinct_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .proto_plan.List flatList = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_flatlist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .proto_plan.RightRefState rightRefState = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_rightrefstate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Plan::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto_plan.Plan)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 plan_node_id = 1;
  if (this->_internal_plan_node_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_plan_node_id(), target);
  }

  // uint32 parent_node_id = 2;
  if (this->_internal_parent_node_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_parent_node_id(), target);
  }

  // .proto_plan.RemoteQueryExecType exec_type = 3;
  if (this->_internal_exec_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_exec_type(), target);
  }

  // double startup_cost = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_startup_cost = this->_internal_startup_cost();
  uint64_t raw_startup_cost;
  memcpy(&raw_startup_cost, &tmp_startup_cost, sizeof(tmp_startup_cost));
  if (raw_startup_cost != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_startup_cost(), target);
  }

  // double total_cost = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_total_cost = this->_internal_total_cost();
  uint64_t raw_total_cost;
  memcpy(&raw_total_cost, &tmp_total_cost, sizeof(tmp_total_cost));
  if (raw_total_cost != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_total_cost(), target);
  }

  // double plan_rows = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_plan_rows = this->_internal_plan_rows();
  uint64_t raw_plan_rows;
  memcpy(&raw_plan_rows, &tmp_plan_rows, sizeof(tmp_plan_rows));
  if (raw_plan_rows != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_plan_rows(), target);
  }

  // double multiple = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_multiple = this->_internal_multiple();
  uint64_t raw_multiple;
  memcpy(&raw_multiple, &tmp_multiple, sizeof(tmp_multiple));
  if (raw_multiple != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(7, this->_internal_multiple(), target);
  }

  // int32 plan_width = 8;
  if (this->_internal_plan_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_plan_width(), target);
  }

  // int32 dop = 9;
  if (this->_internal_dop() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(9, this->_internal_dop(), target);
  }

  // double pred_rows = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pred_rows = this->_internal_pred_rows();
  uint64_t raw_pred_rows;
  memcpy(&raw_pred_rows, &tmp_pred_rows, sizeof(tmp_pred_rows));
  if (raw_pred_rows != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(10, this->_internal_pred_rows(), target);
  }

  // double pred_startup_time = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pred_startup_time = this->_internal_pred_startup_time();
  uint64_t raw_pred_startup_time;
  memcpy(&raw_pred_startup_time, &tmp_pred_startup_time, sizeof(tmp_pred_startup_time));
  if (raw_pred_startup_time != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(11, this->_internal_pred_startup_time(), target);
  }

  // double pred_total_time = 12;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pred_total_time = this->_internal_pred_total_time();
  uint64_t raw_pred_total_time;
  memcpy(&raw_pred_total_time, &tmp_pred_total_time, sizeof(tmp_pred_total_time));
  if (raw_pred_total_time != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(12, this->_internal_pred_total_time(), target);
  }

  // int64 pred_max_memory = 13;
  if (this->_internal_pred_max_memory() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(13, this->_internal_pred_max_memory(), target);
  }

  // int32 recursive_union_plan_nodeid = 14;
  if (this->_internal_recursive_union_plan_nodeid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(14, this->_internal_recursive_union_plan_nodeid(), target);
  }

  // bool recursive_union_controller = 15;
  if (this->_internal_recursive_union_controller() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(15, this->_internal_recursive_union_controller(), target);
  }

  // int32 control_plan_nodeid = 16;
  if (this->_internal_control_plan_nodeid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(16, this->_internal_control_plan_nodeid(), target);
  }

  // bool is_sync_plannode = 17;
  if (this->_internal_is_sync_plannode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->_internal_is_sync_plannode(), target);
  }

  // .proto_plan.List targetlist = 18;
  if (this->_internal_has_targetlist()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        18, _Internal::targetlist(this), target, stream);
  }

  // .proto_plan.List qual = 19;
  if (this->_internal_has_qual()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        19, _Internal::qual(this), target, stream);
  }

  // .proto_plan.Plan lefttree = 20;
  if (this->_internal_has_lefttree()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::lefttree(this), target, stream);
  }

  // .proto_plan.Plan righttree = 21;
  if (this->_internal_has_righttree()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        21, _Internal::righttree(this), target, stream);
  }

  // bool ispwj = 22;
  if (this->_internal_ispwj() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(22, this->_internal_ispwj(), target);
  }

  // int32 paramno = 23;
  if (this->_internal_paramno() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(23, this->_internal_paramno(), target);
  }

  // int32 subparamno = 24;
  if (this->_internal_subparamno() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(24, this->_internal_subparamno(), target);
  }

  // .proto_plan.List initPlan = 25;
  if (this->_internal_has_initplan()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        25, _Internal::initplan(this), target, stream);
  }

  // .proto_plan.List distributed_keys = 26;
  if (this->_internal_has_distributed_keys()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        26, _Internal::distributed_keys(this), target, stream);
  }

  // .proto_plan.ExecNodes exec_nodes = 27;
  if (this->_internal_has_exec_nodes()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        27, _Internal::exec_nodes(this), target, stream);
  }

  // .proto_plan.Bitmapset extParam = 28;
  if (this->_internal_has_extparam()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        28, _Internal::extparam(this), target, stream);
  }

  // .proto_plan.Bitmapset allParam = 29;
  if (this->_internal_has_allparam()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        29, _Internal::allparam(this), target, stream);
  }

  // bool vec_output = 30;
  if (this->_internal_vec_output() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(30, this->_internal_vec_output(), target);
  }

  // bool hasUniqueResults = 31;
  if (this->_internal_hasuniqueresults() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(31, this->_internal_hasuniqueresults(), target);
  }

  // bool isDeltaTable = 32;
  if (this->_internal_isdeltatable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(32, this->_internal_isdeltatable(), target);
  }

  // repeated int32 operatorMemKB = 33;
  {
    int byte_size = _operatormemkb_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          33, _internal_operatormemkb(), byte_size, target);
    }
  }

  // int32 operatorMaxMem = 34;
  if (this->_internal_operatormaxmem() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(34, this->_internal_operatormaxmem(), target);
  }

  // bool parallel_enabled = 35;
  if (this->_internal_parallel_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(35, this->_internal_parallel_enabled(), target);
  }

  // bool hasHashFilter = 36;
  if (this->_internal_hashashfilter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(36, this->_internal_hashashfilter(), target);
  }

  // .proto_plan.List var_list = 37;
  if (this->_internal_has_var_list()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        37, _Internal::var_list(this), target, stream);
  }

  // .proto_plan.List filterIndexList = 38;
  if (this->_internal_has_filterindexlist()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        38, _Internal::filterindexlist(this), target, stream);
  }

  // repeated int32 ng_operatorMemKBArray = 39;
  {
    int byte_size = _ng_operatormemkbarray_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          39, _internal_ng_operatormemkbarray(), byte_size, target);
    }
  }

  // int32 ng_num = 40;
  if (this->_internal_ng_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(40, this->_internal_ng_num(), target);
  }

  // double innerdistinct = 41;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_innerdistinct = this->_internal_innerdistinct();
  uint64_t raw_innerdistinct;
  memcpy(&raw_innerdistinct, &tmp_innerdistinct, sizeof(tmp_innerdistinct));
  if (raw_innerdistinct != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(41, this->_internal_innerdistinct(), target);
  }

  // double outerdistinct = 42;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_outerdistinct = this->_internal_outerdistinct();
  uint64_t raw_outerdistinct;
  memcpy(&raw_outerdistinct, &tmp_outerdistinct, sizeof(tmp_outerdistinct));
  if (raw_outerdistinct != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(42, this->_internal_outerdistinct(), target);
  }

  // .proto_plan.List flatList = 43;
  if (this->_internal_has_flatlist()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        43, _Internal::flatlist(this), target, stream);
  }

  // .proto_plan.RightRefState rightRefState = 44;
  if (this->_internal_has_rightrefstate()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        44, _Internal::rightrefstate(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto_plan.Plan)
  return target;
}

size_t Plan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto_plan.Plan)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 operatorMemKB = 33;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->operatormemkb_);
    if (data_size > 0) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _operatormemkb_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int32 ng_operatorMemKBArray = 39;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->ng_operatormemkbarray_);
    if (data_size > 0) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _ng_operatormemkbarray_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .proto_plan.List targetlist = 18;
  if (this->_internal_has_targetlist()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *targetlist_);
  }

  // .proto_plan.List qual = 19;
  if (this->_internal_has_qual()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *qual_);
  }

  // .proto_plan.Plan lefttree = 20;
  if (this->_internal_has_lefttree()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *lefttree_);
  }

  // .proto_plan.Plan righttree = 21;
  if (this->_internal_has_righttree()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *righttree_);
  }

  // .proto_plan.List initPlan = 25;
  if (this->_internal_has_initplan()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *initplan_);
  }

  // .proto_plan.List distributed_keys = 26;
  if (this->_internal_has_distributed_keys()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *distributed_keys_);
  }

  // .proto_plan.ExecNodes exec_nodes = 27;
  if (this->_internal_has_exec_nodes()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *exec_nodes_);
  }

  // .proto_plan.Bitmapset extParam = 28;
  if (this->_internal_has_extparam()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *extparam_);
  }

  // .proto_plan.Bitmapset allParam = 29;
  if (this->_internal_has_allparam()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *allparam_);
  }

  // .proto_plan.List var_list = 37;
  if (this->_internal_has_var_list()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *var_list_);
  }

  // .proto_plan.List filterIndexList = 38;
  if (this->_internal_has_filterindexlist()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *filterindexlist_);
  }

  // .proto_plan.List flatList = 43;
  if (this->_internal_has_flatlist()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *flatlist_);
  }

  // .proto_plan.RightRefState rightRefState = 44;
  if (this->_internal_has_rightrefstate()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *rightrefstate_);
  }

  // uint32 plan_node_id = 1;
  if (this->_internal_plan_node_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_plan_node_id());
  }

  // uint32 parent_node_id = 2;
  if (this->_internal_parent_node_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_parent_node_id());
  }

  // double startup_cost = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_startup_cost = this->_internal_startup_cost();
  uint64_t raw_startup_cost;
  memcpy(&raw_startup_cost, &tmp_startup_cost, sizeof(tmp_startup_cost));
  if (raw_startup_cost != 0) {
    total_size += 1 + 8;
  }

  // double total_cost = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_total_cost = this->_internal_total_cost();
  uint64_t raw_total_cost;
  memcpy(&raw_total_cost, &tmp_total_cost, sizeof(tmp_total_cost));
  if (raw_total_cost != 0) {
    total_size += 1 + 8;
  }

  // .proto_plan.RemoteQueryExecType exec_type = 3;
  if (this->_internal_exec_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_exec_type());
  }

  // int32 plan_width = 8;
  if (this->_internal_plan_width() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_plan_width());
  }

  // double plan_rows = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_plan_rows = this->_internal_plan_rows();
  uint64_t raw_plan_rows;
  memcpy(&raw_plan_rows, &tmp_plan_rows, sizeof(tmp_plan_rows));
  if (raw_plan_rows != 0) {
    total_size += 1 + 8;
  }

  // double multiple = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_multiple = this->_internal_multiple();
  uint64_t raw_multiple;
  memcpy(&raw_multiple, &tmp_multiple, sizeof(tmp_multiple));
  if (raw_multiple != 0) {
    total_size += 1 + 8;
  }

  // double pred_rows = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pred_rows = this->_internal_pred_rows();
  uint64_t raw_pred_rows;
  memcpy(&raw_pred_rows, &tmp_pred_rows, sizeof(tmp_pred_rows));
  if (raw_pred_rows != 0) {
    total_size += 1 + 8;
  }

  // double pred_startup_time = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pred_startup_time = this->_internal_pred_startup_time();
  uint64_t raw_pred_startup_time;
  memcpy(&raw_pred_startup_time, &tmp_pred_startup_time, sizeof(tmp_pred_startup_time));
  if (raw_pred_startup_time != 0) {
    total_size += 1 + 8;
  }

  // int32 dop = 9;
  if (this->_internal_dop() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_dop());
  }

  // int32 recursive_union_plan_nodeid = 14;
  if (this->_internal_recursive_union_plan_nodeid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_recursive_union_plan_nodeid());
  }

  // double pred_total_time = 12;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pred_total_time = this->_internal_pred_total_time();
  uint64_t raw_pred_total_time;
  memcpy(&raw_pred_total_time, &tmp_pred_total_time, sizeof(tmp_pred_total_time));
  if (raw_pred_total_time != 0) {
    total_size += 1 + 8;
  }

  // int64 pred_max_memory = 13;
  if (this->_internal_pred_max_memory() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_pred_max_memory());
  }

  // int32 control_plan_nodeid = 16;
  if (this->_internal_control_plan_nodeid() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_control_plan_nodeid());
  }

  // bool recursive_union_controller = 15;
  if (this->_internal_recursive_union_controller() != 0) {
    total_size += 1 + 1;
  }

  // bool is_sync_plannode = 17;
  if (this->_internal_is_sync_plannode() != 0) {
    total_size += 2 + 1;
  }

  // bool ispwj = 22;
  if (this->_internal_ispwj() != 0) {
    total_size += 2 + 1;
  }

  // bool vec_output = 30;
  if (this->_internal_vec_output() != 0) {
    total_size += 2 + 1;
  }

  // int32 paramno = 23;
  if (this->_internal_paramno() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_paramno());
  }

  // int32 subparamno = 24;
  if (this->_internal_subparamno() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_subparamno());
  }

  // bool hasUniqueResults = 31;
  if (this->_internal_hasuniqueresults() != 0) {
    total_size += 2 + 1;
  }

  // bool isDeltaTable = 32;
  if (this->_internal_isdeltatable() != 0) {
    total_size += 2 + 1;
  }

  // bool parallel_enabled = 35;
  if (this->_internal_parallel_enabled() != 0) {
    total_size += 2 + 1;
  }

  // bool hasHashFilter = 36;
  if (this->_internal_hashashfilter() != 0) {
    total_size += 2 + 1;
  }

  // int32 operatorMaxMem = 34;
  if (this->_internal_operatormaxmem() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_operatormaxmem());
  }

  // double innerdistinct = 41;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_innerdistinct = this->_internal_innerdistinct();
  uint64_t raw_innerdistinct;
  memcpy(&raw_innerdistinct, &tmp_innerdistinct, sizeof(tmp_innerdistinct));
  if (raw_innerdistinct != 0) {
    total_size += 2 + 8;
  }

  // double outerdistinct = 42;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_outerdistinct = this->_internal_outerdistinct();
  uint64_t raw_outerdistinct;
  memcpy(&raw_outerdistinct, &tmp_outerdistinct, sizeof(tmp_outerdistinct));
  if (raw_outerdistinct != 0) {
    total_size += 2 + 8;
  }

  // int32 ng_num = 40;
  if (this->_internal_ng_num() != 0) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_ng_num());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Plan::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Plan::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Plan::GetClassData() const { return &_class_data_; }

void Plan::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Plan *>(to)->MergeFrom(
      static_cast<const Plan &>(from));
}


void Plan::MergeFrom(const Plan& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto_plan.Plan)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  operatormemkb_.MergeFrom(from.operatormemkb_);
  ng_operatormemkbarray_.MergeFrom(from.ng_operatormemkbarray_);
  if (from._internal_has_targetlist()) {
    _internal_mutable_targetlist()->::proto_plan::List::MergeFrom(from._internal_targetlist());
  }
  if (from._internal_has_qual()) {
    _internal_mutable_qual()->::proto_plan::List::MergeFrom(from._internal_qual());
  }
  if (from._internal_has_lefttree()) {
    _internal_mutable_lefttree()->::proto_plan::Plan::MergeFrom(from._internal_lefttree());
  }
  if (from._internal_has_righttree()) {
    _internal_mutable_righttree()->::proto_plan::Plan::MergeFrom(from._internal_righttree());
  }
  if (from._internal_has_initplan()) {
    _internal_mutable_initplan()->::proto_plan::List::MergeFrom(from._internal_initplan());
  }
  if (from._internal_has_distributed_keys()) {
    _internal_mutable_distributed_keys()->::proto_plan::List::MergeFrom(from._internal_distributed_keys());
  }
  if (from._internal_has_exec_nodes()) {
    _internal_mutable_exec_nodes()->::proto_plan::ExecNodes::MergeFrom(from._internal_exec_nodes());
  }
  if (from._internal_has_extparam()) {
    _internal_mutable_extparam()->::proto_plan::Bitmapset::MergeFrom(from._internal_extparam());
  }
  if (from._internal_has_allparam()) {
    _internal_mutable_allparam()->::proto_plan::Bitmapset::MergeFrom(from._internal_allparam());
  }
  if (from._internal_has_var_list()) {
    _internal_mutable_var_list()->::proto_plan::List::MergeFrom(from._internal_var_list());
  }
  if (from._internal_has_filterindexlist()) {
    _internal_mutable_filterindexlist()->::proto_plan::List::MergeFrom(from._internal_filterindexlist());
  }
  if (from._internal_has_flatlist()) {
    _internal_mutable_flatlist()->::proto_plan::List::MergeFrom(from._internal_flatlist());
  }
  if (from._internal_has_rightrefstate()) {
    _internal_mutable_rightrefstate()->::proto_plan::RightRefState::MergeFrom(from._internal_rightrefstate());
  }
  if (from._internal_plan_node_id() != 0) {
    _internal_set_plan_node_id(from._internal_plan_node_id());
  }
  if (from._internal_parent_node_id() != 0) {
    _internal_set_parent_node_id(from._internal_parent_node_id());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_startup_cost = from._internal_startup_cost();
  uint64_t raw_startup_cost;
  memcpy(&raw_startup_cost, &tmp_startup_cost, sizeof(tmp_startup_cost));
  if (raw_startup_cost != 0) {
    _internal_set_startup_cost(from._internal_startup_cost());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_total_cost = from._internal_total_cost();
  uint64_t raw_total_cost;
  memcpy(&raw_total_cost, &tmp_total_cost, sizeof(tmp_total_cost));
  if (raw_total_cost != 0) {
    _internal_set_total_cost(from._internal_total_cost());
  }
  if (from._internal_exec_type() != 0) {
    _internal_set_exec_type(from._internal_exec_type());
  }
  if (from._internal_plan_width() != 0) {
    _internal_set_plan_width(from._internal_plan_width());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_plan_rows = from._internal_plan_rows();
  uint64_t raw_plan_rows;
  memcpy(&raw_plan_rows, &tmp_plan_rows, sizeof(tmp_plan_rows));
  if (raw_plan_rows != 0) {
    _internal_set_plan_rows(from._internal_plan_rows());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_multiple = from._internal_multiple();
  uint64_t raw_multiple;
  memcpy(&raw_multiple, &tmp_multiple, sizeof(tmp_multiple));
  if (raw_multiple != 0) {
    _internal_set_multiple(from._internal_multiple());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pred_rows = from._internal_pred_rows();
  uint64_t raw_pred_rows;
  memcpy(&raw_pred_rows, &tmp_pred_rows, sizeof(tmp_pred_rows));
  if (raw_pred_rows != 0) {
    _internal_set_pred_rows(from._internal_pred_rows());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pred_startup_time = from._internal_pred_startup_time();
  uint64_t raw_pred_startup_time;
  memcpy(&raw_pred_startup_time, &tmp_pred_startup_time, sizeof(tmp_pred_startup_time));
  if (raw_pred_startup_time != 0) {
    _internal_set_pred_startup_time(from._internal_pred_startup_time());
  }
  if (from._internal_dop() != 0) {
    _internal_set_dop(from._internal_dop());
  }
  if (from._internal_recursive_union_plan_nodeid() != 0) {
    _internal_set_recursive_union_plan_nodeid(from._internal_recursive_union_plan_nodeid());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pred_total_time = from._internal_pred_total_time();
  uint64_t raw_pred_total_time;
  memcpy(&raw_pred_total_time, &tmp_pred_total_time, sizeof(tmp_pred_total_time));
  if (raw_pred_total_time != 0) {
    _internal_set_pred_total_time(from._internal_pred_total_time());
  }
  if (from._internal_pred_max_memory() != 0) {
    _internal_set_pred_max_memory(from._internal_pred_max_memory());
  }
  if (from._internal_control_plan_nodeid() != 0) {
    _internal_set_control_plan_nodeid(from._internal_control_plan_nodeid());
  }
  if (from._internal_recursive_union_controller() != 0) {
    _internal_set_recursive_union_controller(from._internal_recursive_union_controller());
  }
  if (from._internal_is_sync_plannode() != 0) {
    _internal_set_is_sync_plannode(from._internal_is_sync_plannode());
  }
  if (from._internal_ispwj() != 0) {
    _internal_set_ispwj(from._internal_ispwj());
  }
  if (from._internal_vec_output() != 0) {
    _internal_set_vec_output(from._internal_vec_output());
  }
  if (from._internal_paramno() != 0) {
    _internal_set_paramno(from._internal_paramno());
  }
  if (from._internal_subparamno() != 0) {
    _internal_set_subparamno(from._internal_subparamno());
  }
  if (from._internal_hasuniqueresults() != 0) {
    _internal_set_hasuniqueresults(from._internal_hasuniqueresults());
  }
  if (from._internal_isdeltatable() != 0) {
    _internal_set_isdeltatable(from._internal_isdeltatable());
  }
  if (from._internal_parallel_enabled() != 0) {
    _internal_set_parallel_enabled(from._internal_parallel_enabled());
  }
  if (from._internal_hashashfilter() != 0) {
    _internal_set_hashashfilter(from._internal_hashashfilter());
  }
  if (from._internal_operatormaxmem() != 0) {
    _internal_set_operatormaxmem(from._internal_operatormaxmem());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_innerdistinct = from._internal_innerdistinct();
  uint64_t raw_innerdistinct;
  memcpy(&raw_innerdistinct, &tmp_innerdistinct, sizeof(tmp_innerdistinct));
  if (raw_innerdistinct != 0) {
    _internal_set_innerdistinct(from._internal_innerdistinct());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_outerdistinct = from._internal_outerdistinct();
  uint64_t raw_outerdistinct;
  memcpy(&raw_outerdistinct, &tmp_outerdistinct, sizeof(tmp_outerdistinct));
  if (raw_outerdistinct != 0) {
    _internal_set_outerdistinct(from._internal_outerdistinct());
  }
  if (from._internal_ng_num() != 0) {
    _internal_set_ng_num(from._internal_ng_num());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Plan::CopyFrom(const Plan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto_plan.Plan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Plan::IsInitialized() const {
  return true;
}

void Plan::InternalSwap(Plan* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  operatormemkb_.InternalSwap(&other->operatormemkb_);
  ng_operatormemkbarray_.InternalSwap(&other->ng_operatormemkbarray_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Plan, ng_num_)
      + sizeof(Plan::ng_num_)
      - PROTOBUF_FIELD_OFFSET(Plan, targetlist_)>(
          reinterpret_cast<char*>(&targetlist_),
          reinterpret_cast<char*>(&other->targetlist_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Plan::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_query_5fplan_2eproto_getter, &descriptor_table_query_5fplan_2eproto_once,
      file_level_metadata_query_5fplan_2eproto[1]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto_plan
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::proto_plan::RightRefState* Arena::CreateMaybeMessage< ::proto_plan::RightRefState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto_plan::RightRefState >(arena);
}
template<> PROTOBUF_NOINLINE ::proto_plan::Plan* Arena::CreateMaybeMessage< ::proto_plan::Plan >(Arena* arena) {
  return Arena::CreateMessageInternal< ::proto_plan::Plan >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
